МИНОБРНАУКИ РОССИИ
Федеральное государственное бюджетное образовательное
учреждение высшего образования
«Ярославский государственный университет им. П.Г. Демидова»


Кафедра компьютерной безопасности и математических методов обработки информации













Дипломная работа
Разработка системы альтернативного управления компьютером.
(Специальность 10.05.01 Компьютерная безопасность) 
                                                
                                                
                                                
                                                
                                                
                                                
                                                Научный руководитель
                                                                                   
                                                     Д-р наук, профессор
                                                          (степень, звание)
                                                                     В.Г. Дурнев
                                                          (подпись) (ФИО)
                                                «___» _________ 20__ г.
                                                
                                                Студент группы КБ-61СО
                      С.М. Соловьев
                                                           (подпись) (ФИО)
                                                «___» _________ 20__ г.
                                                
                                                
                                                
                                                
Ярославль 2017 г.
   Оглавление
Введение	4
Цель работы	4
Глава 1. Введение в биологическую терминологию	5
1.1 Структура человеческого глаза	5
1.2 Фиксация глаза	5
1.3 Перемещения глаза	6
Глава 2. Методы поиска объектов на изображении	8
2.1 Нейронные сети	8
2.1.1 Введение в терминологию	8
2.1.2 «Классические» нейронные сети	9
2.1.3 Алгоритмы обучения	14
2.1.4 Сверточные нейронные сети	17
2.2 Метод Виолы-Джонса	18
2.2.1 Принцип сканирующего окна	18
2.2.2 Интегральное представление изображений	19
2.2.3 Признаки Хаара	21
2.2.4 Используемая в алгоритме модель машинного обучения	25
2.2.5 Обучение классификатора в методе Виолы-Джонса	25
2.3 Вывод	27
Глава 3. Алгоритмы распознавания взгляда	28
3.1 Инфракрасное отражение	28
3.2 Алгоритм отслеживания взгляда в реальном времени с компенсацией движения головы(RTAC)	29
Глава 4. Концепция приложения	31
4.1 Технические проблемы	31
4.2 Алгоритм	31
4.3 Получение координат частей лица	34
4.4 Определение угла положения головы	34
4.5 Определение направления взгляда	35
4.6 Объединение и аппроксимирование результата	36
4.6.1 Упрощенный способ объединения сигналов	37
4.6.2 Модифицированный способ объединения сигналов	37
Глава 5. Реализация проекта	40
5.1 Поиск пары глаз	40
5.2 Определение зрачка	41
5.2.1 Бинаризация изображения	41
5.3 Поиск угла	44
Глава 6. Экспериментальная оценка эффективности системы	46
Заключение	46
Список литературы	47
   
   

  Введение
   Человек на протяжении своей жизни, по разным данным, получает от 80 % до более 90% информации с помощью зрения. Все привыкли считать глаза неким «устройством» для получения информации, но мало кто задумывался о том, что глаза также могут передавать информацию.
   Несколько лет назад такое предложение могло показаться странным, но теперь технологии шагнули далеко вперед, и это стало реальностью. С помощью глаз можно передавать информацию о том, куда смотрит человек, на чем сфокусирован его взгляд, на чем он сосредоточен.
   Использовать данную технологию можно для обучения маленьких детей или детей с заторможенным развитием. На экране одновременно отображаются несколько изображений. Обучаемого просят посмотреть на какое-то конкретное по разным характеристикам (цвет, вид, форма и т.д.). Также маркетологи могут измерять эффективность рекламы, демонстрируя ее людям и фиксировать координаты объекта внимания человека. Но, пожалуй, самая главное направление использования подобной технологии – это помощь людям с ограниченными физическими возможностями в использовании ПК для общения, саморазвития, работы или управления другими устройствами.
   Данный проект создан для реализации приложения с открытым исходным кодом и бесплатной лицензией на использование и распространение продукта.
Цель работы
 Спроектировать приложение для управления ПК взглядом.
 Разработать прототип приложения.
 Спланировать дальнейшее развитие приложения.


  Глава 1. Введение в биологическую терминологию
   Используя ПК или мобильное устройство, человек устремляет взгляд на конкретные секторы экрана. Фиксацию взгляда на конкретном секторе будем называть фокусом взгляда. Для управления ПК требуется постоянный трекинг (слежение) фокуса взгляда. Для понимания физики процесса требуется информация о биологии и поведении глаза. Данный раздел предоставит некоторые базовые знания для создания системы глазного трекинга.
1.1 Структура человеческого глаза
   Для того чтобы человек мог максимально четко рассмотреть объект, ему требуется сфокусировать на нем взгляд. Получение изображения происходит при попадании его через хрусталик на рецепторы глаза. Важным фактором при рассмотрении структуры глаза является то, где располагаются эти рецепторы. В [2] говорится, что если бы рецепторы были расположены равномерно внутри глаза, то была бы проблема понять, как происходит фокусирование. Вместо этого мы имеем различную плотность распределения рецепторов. Наиболее четкое изображение человек получает при попадании его в точку максимального скопления фоторецепторов-колбочек, и эта точка находится в желтой ямке (пятно фовеа).
1.2 Фиксация глаза
   Но, нельзя забывать, что человеческий зрачок не может замереть на месте для получения стабильного изображения. В [1] используют понятие дрейфа. Дрейф представляет собой неупорядоченное и относительно медленное движение осей глаз, при котором для каждого глаза изображение точки фиксации остается внутри фовеа. Дрейф всегда сопровождается тремором – высоким по частоте, но очень маленьким по амплитуде колебательным движением осей глаз. Проще говоря, глаз даже при фокусировке изображения немного дергается, незаметно для самого человека.
   Так как желтая ямка находится внутри глаза и имеет крайне малый размер (диаметр чуть больше 1мм), то фиксировать изменение ее положения не предоставляется  возможным. Вместо этого можно отслеживать зрачок и через него выводить точку фокусировки, это становится возможным потому что, объект фокуса находится в центре глаза.
                                            
Локализация центральной ямки (0 градусов) и различных областей сетчатки по отношению к ней (в градусах эксцентриситета).

1.3 Перемещения глаза
Человеческий глаз может прибывать только в двух состояниях: фокусировка, сопровождающаяся дрейфом и перемещение (саккада).
Саккады (от старинного французского слова, переводимого как «хлопок паруса») — быстрые, строго согласованные движения глаз, происходящие одновременно и в одном направлении.  В работе [3] было обнаружено, что «трансаккадная пространственная память приносится в жертву, чтобы поддерживать перцептивную стабильность»[3]. Это означает, что во время саккадного движения визуальная информация не получается, чтобы сохранить восприятие гладкости и стабильности. Этот эффект известен как саккадическое подавление. Подобным эффектом обладает постоянное использование мыши в качестве интерфейса управления ПК, оно оттачивает навык до сглаженных, точных перемещений курсора в нужное положение. 
Саккады важно отличать от других движений глаз, называемых Saccadic Eye Movements (SACs) в [5] (Преследование, вергентное и вестибулярное). Преследование – движения глаз «преследуют» точку фокусировки, перемещающийся в пространстве, выполняя саккады, чтобы догнать, если точка движется слишком быстро. Движение заметно медленнее, чем у саккад. Вергентные движения (лат. Vergo - склоняюсь) - макродвижения глаз, приводящие к изменению угла между зрительными осями левого и правого глаза. Вергентные движения – выступают фактором, обеспечивающим бинокулярное зрение. Они разделяются на движения конвергенции – сводящие глаза, дивергенции –разводящие глаза, циклофузионные, или торсионные движения, меняющие ориентации сетчаток левого и правого глаз. Вестибулярные движения - это вращения глаза, чтобы компенсировать большие движения головы или тела (стабилизация изображения). Эти три движения менее важны, чем саккады для обработки информации, и как таковые для отслеживания зрачков.


Глава 2. Методы поиска объектов на изображении
Самые точные методы для обнаружения глаз включают в себя инвазивное или дорогостоящие оборудование. В [2] упоминается метод, который использует контактную линзу, с металлическим кольцом. Фиксация координат происходит с помощью измерения магнитного поля. В [6] в качестве системы фиксации изображения используют шлем с ИК камерами. Минусы данных систем заключаются в том, что они неудобны для использования, не мобильны. 
2.1 Нейронные сети
2.1.1 Введение в терминологию
Иску?сственная нейро?нная се?ть (ИНС) — математическая модель, а также её программное или аппаратное воплощение, построенная по принципу организации и функционирования биологических нейронных сетей — сетей нервных клеток живого организма. Это понятие возникло при изучении процессов, протекающих в мозге, и при попытке смоделировать эти процессы. Первой такой попыткой были нейронные сети У. Маккалока и У. Питтса. После разработки алгоритмов обучения получаемые модели стали использовать в практических целях: в задачах прогнозирования, для распознавания образов, в задачах управления и др.
ИНС представляет собой систему соединённых и взаимодействующих между собой простых процессоров (искусственных нейронов). Такие процессоры обычно довольно просты (особенно в сравнении с процессорами, используемыми в персональных компьютерах). Каждый процессор подобной сети имеет дело только с сигналами, которые он периодически получает, и сигналами, которые он периодически посылает другим процессорам. И, тем не менее, будучи соединёнными в достаточно большую сеть с управляемым взаимодействием, такие по отдельности простые процессоры вместе способны выполнять довольно сложные задачи.
С точки зрения машинного обучения, нейронная сеть представляет собой частный случай методов распознавания образов, дискриминантного анализа, методов кластеризации и т. п.
С математической точки зрения, обучение нейронных сетей — это многопараметрическая задача нелинейной оптимизации.
С точки зрения кибернетики, нейронная сеть используется в задачах адаптивного управления и как алгоритмы для робототехники.
С точки зрения развития вычислительной техники и программирования, нейронная сеть — способ решения проблемы эффективного параллелизма.
А с точки зрения искусственного интеллекта, ИНС является основой философского течения коннективизма и основным направлением в структурном подходе по изучению возможности построения (моделирования) естественного интеллекта с помощью компьютерных алгоритмов.
2.1.2 «Классические» нейронные сети
Большинство людей под «обычными» или «классическими» нейросетями понимает полносвязные нейронные сети прямого распространения с обратным распространением ошибки:

Перцептро?н, или персептрон(англ. perceptron от лат. perceptio — восприятие; нем. Perzeptron) — математическая или компьютерная модель восприятия информации мозгом (кибернетическаямодель мозга), предложенная Фрэнком Розенблаттом в 1957 году и впервые реализованная в виде электронной машины «Марк-1» в 1960 году. Перцептрон стал одной из первых моделей нейросетей, а «Марк-1» — первым в мире нейрокомпьютером.
Перцептрон состоит из трёх типов элементов, а именно: поступающие от датчиков сигналы передаются ассоциативным элементам, а затем реагирующим элементам. Таким образом, перцептроны позволяют создать набор «ассоциаций» между входными стимулами и необходимой реакцией на выходе. В биологическом плане это соответствует преобразованию, например, зрительной информации в физиологический ответ от двигательных нейронов. Согласно современной терминологии, перцептроны могут быть классифицированы как искусственные нейронные сети:
с одним скрытым слоем;
с пороговой передаточной функцией;
с прямым распространением сигнала.

Элементарный перцептрон состоит из элементов трёх типов: S-элементов, A-элементов и одного R-элемента.
S-элементы — это слой сенсоров или рецепторов. В физическом воплощении они соответствуют, например, светочувствительным клеткам сетчатки глаза или фоторезисторам матрицы камеры. Каждый рецептор может находиться в одном из двух состояний — покоя или возбуждения, и только в последнем случае он передаёт единичный сигнал в следующий слой, ассоциативным элементам.
A-элементы называются ассоциативными, потому что каждому такому элементу, как правило, соответствует целый набор (ассоциация) S-элементов. A-элемент активизируется, как только количество сигналов от S-элементов на его входе превысило некоторую величину ?. Таким образом, если набор соответствующих S-элементов располагается на сенсорном поле в форме буквы «Д», A-элемент активизируется, если достаточное количество рецепторов сообщило о появлении «белого пятна света» в их окрестности, то есть A-элемент будет как бы ассоциирован с наличием/отсутствием буквы «Д» в некоторой области.
Сигналы от возбудившихся A-элементов, в свою очередь, передаются в сумматор R, причём сигнал от i-го ассоциативного элемента передаётся с коэффициентом wi. Этот коэффициент называется весом A—R связи.
Так же как и A-элементы, R-элемент подсчитывает сумму значений входных сигналов, помноженных на веса (линейную форму). R-элемент, а вместе с ним и элементарный перцептрон, выдаёт «1», если линейная форма превышает порог ?, иначе на выходе будет «-1». Математически, функцию, реализуемую R-элементом, можно записать так:
f(x)=sign(?_(i=1)^n??w_i x_i- ??
Обучение элементарного перцептрона состоит в изменении весовых коэффициентов wi cвязей A—R. Веса связей S—A (которые могут принимать значения {-1; 0; +1}) и значения порогов A-элементов выбираются случайным образом в самом начале и затем не изменяются.
После обучения перцептрон готов работать в режиме распознавания или обобщения. В этом режиме перцептрону предъявляются ранее неизвестные ему объекты, и перцептрон должен установить, к какому классу они принадлежат. Работа перцептрона состоит в следующем: при предъявлении объекта возбудившиеся A-элементы передают сигнал R-элементу, равный сумме соответствующих коэффициентов wi. Если эта сумма положительна, то принимается решение, что данный объект принадлежит к первому классу, а если она отрицательна — то ко второму.
Описание на основе предикатов
Марвин Минский изучал свойства параллельных вычислений, частным случаем которых на то время был перцептрон. Для анализа его свойств ему пришлось переизложить теорию перцептронов на язык предикатов. Суть подхода заключалась в следующем[20]:
множеству сигналов от S-элементов была сопоставлена переменная X;
каждому A-элементу был сопоставлен предикат ?(X), названный частным предикатом;
каждому R-элементу был сопоставлен предикат ?, зависящий от частных предикатов;
наконец, перцептроном было названо устройство, способное вычислять все предикаты типа ?.
Применительно к «зрительному» перцептрону, переменная X символизировала образ какой-либо геометрической фигуры (стимул). Частный предикат позволял «распознавать» каждый свою фигуру. Предикат ? означал ситуацию, когда линейная комбинация  a_1 ?_1+…+ a_n ?_1 ( ai — коэффициенты передачи) превышала некоторый порог ?.
Учёные выделили 5 семейств перцептронов, обладающих, по их мнению, интересными свойствами:[20]
Перцептроны, ограниченные по диаметру — каждая фигура X, распознаваемая частными предикатами, не превосходит по диаметру некоторую фиксированную величину.
Перцептроны ограниченного порядка — каждый частный предикат зависит от ограниченного количества точек из X.
Перцептроны Гамбы — каждый частный предикат должен быть линейной пороговой функцией, то есть мини-перцептроном.
Случайные перцептроны — перцептроны ограниченного порядка, где частные предикаты представляют собой случайно выбранные булевы функции. В книге отмечается, что именно эта модель наиболее подробно изучалась группой Розенблатта.
Ограниченные перцептроны — множество частных предикатов бесконечно, а множество возможных значений коэффициентов  ai конечно.
Хотя такой математический аппарат позволил применить анализ только к элементарному перцептрону Розенблатта, он вскрыл много принципиальных ограничений для параллельных вычислений, от которых не свободен ни один вид современных искусственных нейронных сетей.
2.1.3 Алгоритмы обучения
Важным свойством любой нейронной сети является способность к обучению. Процесс обучения является процедурой настройки весов и порогов с целью уменьшения разности между желаемыми (целевыми) и получаемыми векторами на выходе. В своей книге Розенблатт пытался классифицировать различные алгоритмы обучения перцептрона, называя их системами подкрепления.
Система подкрепления — это любой набор правил, на основании которых можно изменять с течением времени матрицу взаимодействия (или состояние памяти) перцептрона[21].
Описывая эти системы подкрепления и уточняя возможные их виды, Розенблатт основывался на идеях Д. Хебба об обучении, предложенных им в 1949 году[22], которые можно перефразировать в следующее правило, состоящее из двух частей:
Если два нейрона по обе стороны синапса (соединения) активизируются одновременно (то есть синхронно), то прочность этого соединения возрастает.
Если два нейрона по обе стороны синапса активизируются асинхронно, то такой синапс ослабляется или вообще отмирает[21].
2.1.3.1 Обучение с учителем 
Классический метод обучения перцептрона — это метод коррекции ошибки[23]. Он представляет собой такой вид обучения с учителем, при котором вес связи не изменяется до тех пор, пока текущая реакция перцептрона остается правильной. При появлении неправильной реакции вес изменяется на единицу, а знак (+/-) определяется противоположным от знака ошибки.
Допустим, мы хотим обучить перцептрон разделять два класса объектов так, чтобы при предъявлении объектов первого класса выход перцептрона был положителен (+1), а при предъявлении объектов второго класса — отрицательным (-1). Для этого выполним следующий алгоритм: 
Случайным образом выбираем пороги для A-элементов и устанавливаем связи S—A (далее они изменяться не будут).
Начальные коэффициенты wi полагаем равными нулю.
Предъявляем обучающую выборку: объекты (например, круги либо квадраты) с указанием класса, к которым они принадлежат.
Показываем перцептрону объект первого класса. При этом некоторые A-элементы возбудятся. wi, соответствующие этим возбуждённым элементам, увеличиваем на 1.
Предъявляем объект второго класса и коэффициенты wi тех A-элементов, которые возбудятся при этом показе, уменьшаем на 1.
Обе части шага 3 выполним для всей обучающей выборки. В результате обучения сформируются значения весов связей wi.
Теорема сходимости перцептрона[23], описанная и доказанная Ф. Розенблаттом (с участием Блока, Джозефа, Кестена и других исследователей, работавших вместе с ним), показывает, что элементарный перцептрон, обучаемый по такому алгоритму, независимо от начального состояния весовых коэффициентов и последовательности появления стимулов всегда приведёт к достижению решения за конечный промежуток времени.
2.1.3.2 Обучение без учителя
Кроме классического метода обучения перцептрона Розенблатт также ввёл понятие об обучении без учителя, предложив следующий способ обучения:
Альфа-система подкрепления — это система подкрепления, при которой веса всех активных связей wi, которые ведут к элементу wi, изменяются на одинаковую величину r, а веса неактивных связей за это время не изменяются[25].
Затем, с разработкой понятия многослойного перцептрона, альфа-система была модифицирована и её стали называть дельта-правило. Модификация была проведена с целью сделать функцию обучения дифференцируемой (например, сигмоидной), что в свою очередь нужно для применения метода градиентного спуска, благодаря которому возможно обучение более одного слоя.
2.1.3.3 Метод обратного распространения ошибки
Для обучения многослойных сетей рядом учёных, в том числе Д. Румельхартом, был предложен градиентный алгоритм обучения с учителем, проводящий сигнал ошибки, вычисленный выходами перцептрона, к его входам, слой за слоем. Сейчас это самый популярный метод обучения многослойных перцептронов. Его преимущество в том, что он может обучить все слои нейронной сети, и его легко просчитать локально. Однако этот метод является очень долгим, к тому же, для его применения нужно, чтобы передаточная функция нейронов была дифференцируемой. При этом в перцептронах пришлось отказаться от бинарного сигнала, и пользоваться на входе непрерывными значениями[26].
2.1.3.4 Сигмоидальные функции активации
Наиболее часто в качестве функций активации используются следующие виды сигмоид:
Функция Ферми (экспоненциальная сигмоида):
f(s)= 1/(1+e^(-2?s) )
Рациональная сигмоида (при ? =0 вырождается в так называемую пороговую функцию активации):
f(s)= s/(|s|+ ?)
Гиперболический тангенс:
f(s)=th(s/?)=?(e?^(s/?)- e^((-s)/?))/?(e?^(s/?)+e^((-s)/?)),
где s — выход сумматора нейрона, ? — произвольная константа.

Менее всего, сравнительно с другими сигмоидами, процессорного времени требует расчет рациональной сигмоиды. Для вычисления гиперболического тангенса требуется больше всего тактов работы процессора. Если же сравнивать с пороговыми функциями активации, то сигмоиды рассчитываются очень медленно. Если после суммирования в пороговой функции сразу можно начинать сравнение с определенной величиной (порогом), то в случае сигмоидальной функции активации нужно рассчитать сигмоид (затратить время в лучшем случае на три операции: взятие модуля, сложение и деление), и только потом сравнивать с пороговой величиной (например, нулём). Если считать, что все простейшие операции рассчитываются процессором за примерно одинаковое время, то работа сигмоидальной функции активации после произведённого суммирования (которое займёт одинаковое время) будет медленнее пороговой функции активации как 1:4.
2.1.4 Сверточные нейронные сети
Сверточная нейронная сеть (англ. convolutional neural network, CNN) — специальная архитектура искусственных нейронных сетей, предложенная Яном Лекуном в 1988 году и нацеленная на эффективное распознавание изображений, входит в состав технологий глубинного обучения (англ. deep learning). Таким образом, идея сверточных нейронных сетей заключается в чередовании сверточных слоев (англ. convolution layers) и субдискретизирующих слоев (англ. subsampling layers или англ. pooling layers, слоёв подвыборки). Структура сети — однонаправленная (без обратных связей), принципиально многослойная. Для обучения используются стандартные методы, чаще всего метод обратного распространения ошибки. Функция активации нейронов (передаточная функция) — любая, по выбору исследователя.

Название архитектура сети получила из-за наличия операции свёртки, суть которой в том, что каждый фрагмент изображения умножается на матрицу (ядро) свёртки поэлементно, а результат суммируется и записывается в аналогичную позицию выходного изображения.
2.2 Метод Виолы-Джонса
Хотя метод был разработан и представлен в 2001 году Полом Виолой и Майклом Джонсом [17, 18], он до сих пор на момент написания данной работы является основополагающим для поиска объектов на изображении в реальном времени.[18]
Основные принципы, на которых основан метод, таковы:
 используются изображения в интегральном представлении, что позволяет вычислять быстро необходимые объекты;
 используются признаки Хаара, с помощью которых происходит поиск нужного объекта (в данном контексте, лица и его черт);
 используется бустинг (от англ. Boost – улучшение, усиление) для выбора наиболее подходящих признаков для искомого объекта на данной части изображения;
 все признаки поступают на вход классификатора, который даёт результат «верно» либо «ложь»;
 используются каскады признаков для быстрого отбрасывания окон, где не найдено лицо.
Требуется подробный разбор принципов, на которых основан алгоритм Виолы-Джонса. Данный метод в общем виде ищет лица и черты лица по общему принципу сканирующего окна.
2.2.1 Принцип сканирующего окна
В общем виде, задача обнаружения лица и черт лица человека на цифровом изображении выглядит именно так:
 Имеется изображение, на котором есть искомые объекты. Оно представлено двумерной матрицей пикселей размером w*h, в которой каждый пиксель имеет значение:
— от 0 до 255, если это черно-белое изображение;
— от 0 до 2553, если это цветное изображение (компоненты R, G, B).
 в результате своей работы, алгоритм должен определить лица и их черты и пометить их – поиск осуществляется в активной области изображения прямоугольными признаками, с помощью которых и описывается найденное лицо и его черты:
?rectangle?_i={x, y, w, h,a}  (1.1)
где x, y – координаты центра i-го прямоугольника, w – ширина, h – высота, a – угол наклона прямоугольника к вертикальной оси изображения.

2.2.2 Интегральное представление изображений
Для того, чтобы производить какие-либо действия с данными, используется интегральное представление изображений [19] в методе Виолы-Джонса. Такое представление используется часто и в других методах, к примеру, в вейвлет-преобразованиях, SURF и многих других разобранных алгоритмах. Интегральное представление позволяет быстро рассчитывать суммарную яркостьпроизвольного прямоугольника на данном изображении, причем какой бы прямоугольник не был, время расчета неизменно.
Интегральное представление изображения – это матрица, совпадающая по размерам с исходным изображением. В каждом элементе ее хранится сумма интенсивностей всех пикселей, находящихся левее и выше данного элемента. Элементы матрицы рассчитываются по следующей формуле:
L(x,y)= ?_(i=0, j=0)^(i ?x, j?y)??I(i,j)? (1.2)
где I(i,j) — яркость пикселя исходного изображения.
Каждый элемент матрицы L[x,y] представляет собой сумму пикселей в прямоугольнике от (0,0) до (x,y), т.е. значение каждого пикселя (x,y) равно сумме значений всех пикселов левее и выше данного пикселя (x,y). Расчет матрицы занимает линейное время, пропорциональное числу пикселей в изображении, поэтому интегральное изображение просчитывается за один проход.
Расчет матрицы возможен по формуле 1.3:
L(x,y)=I(x,y)-L(x-1, y-1)+L(x, y-1)+L(x-1, y) (1.3)
По такой интегральной матрице можно очень быстро вычислить сумму пикселей произвольного прямоугольника, произвольной площади.
Пусть в прямоугольнике ABCD есть интересующий нас объект D:

Из рисунка понятно, что сумму внутри прямоугольника можно выразить через суммы и разности смежных прямоугольников по следующей формуле:
S(ABCD)=L(A)+L(C)-L(B)-L(D) (1.4)
Пример вычисления показан на рисунке ниже:

2.2.3 Признаки Хаара
Признаки Хаара — признаки цифрового изображения, используемые в распознавании образов. Своим названием они обязаны интуитивным сходством с вейвлетами Хаара. Признаки Хаара использовались в первом детекторе лиц, работающем в реальном времени.
Обычно у каждого метода есть основа, то, без чего этот метод не мог бы существовать в принципе, а уже над этой основой строится вся остальная часть. В методе Виолы-Джонса эту основу составляют примитивы Хаара, представляющие собой разбивку заданной прямоугольной области на наборы разнотипных прямоугольных подобластей:

В оригинальной версии алгоритма Виолы-Джонса использовались только примитивы без поворотов, а для вычисления значения признака сумма яркостей пикселей одной подобласти вычиталась из суммы яркостей другой подобласти [8]. В развитии метода были предложены примитивы с наклоном на 45 градусов и несимметричных конфигураций. Также вместо вычисления обычной разности, было предложено приписывать каждой подобласти определенный вес и значения признака вычислять как взвешенную сумму пикселей разнотипных областей [9]:
feature= ?_(i?I=1… N)??w_i*RectSum(r_i)?
Основной причиной, почему в основу метода легли примитивы Хаара, являлась попытка уйти от пиксельного представления с сохранением скорости вычисления признака. Из значений пары пикселей сложно вынести какую-либо осмысленную информацию для классификации, в то время как из двух признаков Хаара строится, например, первый каскад системы по распознаванию лиц, который имеет вполне осмысленную интерпретацию [8]:

Сложность вычисления признака, так же как и получения значения пикселя, остается O(1): значение каждой подобласти можно вычислить скомбинировав 4 значения интегрального представления (Summed Area Table — SAT), которое в свою очередь можно построить заранее один раз для всего изображения за O(n), где n — число пикселей в изображении, используя формулу [9]:
SAT(x, y)=SAT(x, y-1)+ SAT(x-1, y)+ I(x, y)- SAT(x-1, y-1)
SAT(-1, y)=SAT(x, -1)=SAT(-1,-1)=0
Таким образом, создали быстрый алгоритм поиска объектов, который пользуется успехом уже больше десятилетия. Но вернемся к нашим признакам. Для определения принадлежности к классу в каждом каскаде, находится сумма значений слабых классификаторов этого каскада. Каждый слабый классификатор выдает два значения в зависимости от того больше или меньше заданного порога значение признака, принадлежащего этому классификатору. В конце сумма значений слабых классификаторов сравнивается с порогом каскада, и выносится решение, найден объект данным каскадом или нет.
Для разных видов объектов создаются разные XML классификаторы. Существуют базы и приложения, с помощью которых можно получить XML классификатор объекта. Мы воспользуемся каскадом, полученным студентами из Modesto Castrillon-Santana (IUSIANI, University of Las Palmas de Gran Canaria, Spain) в 2006 году. Лицензия открыта для некоммерческого использования. 
Пример структуры описания:

Создается впечатление, что здесь куча непонятных цифр и странной информации, но на самом деле все просто: 
 Дерево объектов — набор слабых классификаторов, на основе которых выносится решение о том, находится объект на изображении или нет,
 Два объекта в узле (без имени) — это параметры конкретного слабого классификатора. 
 Расшифровка первого объекта слева направо: первые два значения в нашем случае не используются, третье — номер признака в общей таблице признаков (она располагается дальше в XML), четвертое — пороговое значение слабого классификатора. Так как у нас используется классификатор, основанный на одноуровневых решающих деревьях (Decision Stump), то если значение признака Хаара меньше порога слабого классификатора (четвертое значение), выбирается значение left_val, если больше —right_val.
Все эти признаки в какой-то степени являются самыми обыкновенными детекторами границ. На основе этого базиса вычисляется решение о том, распознал ли каскад объект на изображении или нет. Второй по важности момент в методе Виола-Джонса — это использование каскадной модели или вырожденного дерева принятия решений: в каждом узле дерева с помощью каскада принимается решение, содержится объект на изображении или нет. Если объект не содержится, то алгоритм заканчивает свою работу, если он может содержаться, то мы переходим к следующему узлу. Обучение построено таким образом, чтобы на начальных уровнях с наименьшими затратами отбрасывать большую часть окон, в которых не может содержаться объект. В случае распознавания лиц — первый уровень содержит всего 2 слабых классификатора, в случае распознавания глаз — 6.
2.2.4 Используемая в алгоритме модель машинного обучения
Обучение машины — это процесс получения модулем новых знаний. Есть признанное определение данному процессу:
«Машинное обучение – это наука, изучающая компьютерные алгоритмы, автоматически улучшающиеся во время работы» (Michel, 1996)
        Данный процесс входит в концепцию и технологию под названием Data mining (извлечение информации и интеллектуальный анализ данных), куда входят помимо Машинного обучения такие дисциплины, как Теория баз данных, Искусственный интеллект, Алгоритмизация, Распознавание образов и прочие. Машинное обучение в методе Виолы-Джонса решает такую задачу как классификация.
2.2.5 Обучение классификатора в методе Виолы-Джонса
        В контексте алгоритма, имеется множество объектов (изображений), разделённых некоторым образом на классы. Задано конечное множество изображений, для которых известно, к какому классу они относятся (к примеру, это может быть класс «фронтальное положение носа»). Это множество называется обучающей выборкой. Классовая принадлежность остальных объектов не известна. Требуется построить алгоритм, способный классифицировать произвольный объект из исходного множества [4].
        Классифицировать объект — значит, указать номер (или наименование класса), к которому относится данный объект.
        Классификация объекта — номер или наименование класса, выдаваемые алгоритмом классификации в результате его применения к данному конкретному объекту.
        Классификатор(classifier) — в задачах классификации это аппроксимирующая функция, выносящая решение, к какому именно классу данный объект принадлежит.
        Обучающая выборка – конечное число данных.
        В машинном обучении задача классификации относится к разделу обучения с учителем когда классы поделены. Распознавание образов по сути своей и есть классификация изображений и сигналов. В случае алгоритма Виолы-Джонса для идентификации и распознавания лица классификация является двухклассовой.
        Постановка классификации выглядит следующим образом:
        Есть X – множество, в котором хранится описание объектов, Y – конечное множество номеров, принадлежащих классам. Между ними есть зависимость – отображение Y*: X => Y. Обучающая выборка представлена Xm = {(x1,y1), …, (xm,ym)}. Конструируется функция f от вектора признаков X, которая выдает ответ для любого возможного наблюдения X и способна классифицировать объект x?X. Данное простое правило должно хорошо работать и на новых данных.
2.3 Вывод
Чтобы отслеживать взгляд пользователя, нам нужно знать, где находится зрачок. Системе не требуется чрезмерно мощная камера, поскольку фиксация глаза – единственные значимые данные, которые требуются, чтобы найти взгляд, и они соответствуют самому длинному периоду времени отсутствия движения глаза. Существует большое количество доступных для использования алгоритмов, в которых используется большее различных методов. Основными требованиями являются:
 обнаружение глаз,
 обнаружение зрачка,
 обнаружение дополнительной функции,
 преобразование в координаты фокуса. 


Глава 3. Алгоритмы распознавания взгляда
Система отслеживания взглядов состоит из сложной комбинации алгоритмов для получения точных координат взгляда. Поиск глаз на изображении – это только часть. Существует много способов комбинирования методов для получения требуемого результата. Рассмотрим некоторые примеры алгоритмов отслеживания взгляда.
3.1 Инфракрасное отражение
Принцип работы метода ИК отражения заключается в том, что повышается контраст между зрачком и радужной оболочкой. Ниже приведен пример использования инфракрасного отражения для обнаружения глаз.
В [7] авторы сначала определяют область 60х60 пикселей (исходное разрешение монитора 1280 ? 1024 пикселей) с ориентировочной оценкой центра зрачка. Поскольку глаза имеют разное расположение от источника ИК света, они имеют разные показатели преломления, зрачок кажется черным, а остальное нет. Использование простого порогового алгоритма для обработки, отфильтрованной серой шкалы изображения, полученного с камеры, проверяются все точки ниже для определения ROI. Пороговое уравнение, использованное в [7], приведено ниже. 
Трудности, возникающие в процессе разработки подобных систем неизбежны. В настоящее время исследования в этой области направлены на создание чувствительного к пользователю и легкодоступного устройства. Идеальным решением для этого является бесконтактное и неинвазивное устройство. Но с такими устройствами возникают новые трудности, такие как алгоритмы поиска головы, глаз, зрачка.
X_pupil=(1 )/N ?_(n=1)^N?x_n 
Y_pupil=(1 )/N ?_(n=1)^N?y_n 
 
Общая идея использования инфракрасного излучения заключается в том, что отражение инфракрасного излучения упрощает процесс определения центра зрачка. Таким образом, уменьшается сложность расчета и повышается точность обнаружения зрачков, повышается эффективность системы отслеживания глаз. Отрицательная сторона этого заключается в потребности инфракрасного света. Также могут быть другие источники света, или тени, которые нарушают это изображение и создают «шум», что усложняет вычисление, но это проблема актуальна для большинства ненавязчивых систем.
3.2 Алгоритм отслеживания взгляда в реальном времени с компенсацией движения головы(RTAC)
Объяснение RTAC в [10] начинается со ссылкой на «Pupil Center Corneal Reflection (PCCR) »[10, стр. 395]. Согласно PCCR, вычисления направления взгляда сначала приобретают вектор блика зрачка, а затем используется функция отображения взгляда. Блик является отражением инфракрасного источника света в глазу. Вектор блика зрачка является двумерным вектором между бликом и зрачком. Затем алгоритм использует функцию для отображения этого вектора к направлению 3D-взгляда. Функция отображения определяется следующими функциями:
?_h=b*?_h* V_x+ a*?_h
?_v=b*?_v* V_y+ a*?_v
Где ?h – угол между направлением взгляда и горизонтальным направлением, а также ?v – угол между направлением взгляда и вертикальным направлением. Коэффициенты, a и b, оцениваются с использованием наборов пар векторов бликов. Следующим шагом в этом алгоритме является вычисление движения головы. Предыдущий расчет не включает адаптацию к движениям головы. Таким образом, система должна компенсировать эти движения головы. Этот расчет довольно сложен. Основа для этого два уравнения:
?I_x=(b_2x ?L_v+ a_2x )?d^2+(b_1x ?L_h+ a_1x )?d+(b_0x ?L_h+ a_0x )  
?I_y=(b_2y ?L_v+ a_2y )?d^2+(b_1y ?L_v+ a_1y )?d+(b_0y ?L_v+ a_0y )
Эти два уравнения описывают изменения в положении головы в горизонтальном и вертикальном положении соответственно. Вывод этих уравнений можно найти в [10, стр. 397].
Метод компенсации, используемый в этом алгоритме, использует два набора уравнений:
 Вычисление пропорционального изменения увеличения и последующее использование этих значений для вычисления значения компенсации в горизонтальном и вертикальном направлениях. [10, стр. 397].
 Затем следующим шагом является фиксация головы пользователя во время калибровки, чтобы получить начальные требуемые параметры. После этой калибровки пользователь может свободно перемещать свою голову и параметры сравниваются, чтобы выполнить вычисления.
В [10] было обнаружено, что этот алгоритм имел точность порядка 1 градуса, И что между разными предметами мало что изменилось. Существовала также небольшая разница между различными положениями головы, но ошибка действительно возрастала, когда голова перемещалась около границ видения камеры.
 

Глава 4. Концепция приложения
Для реализации проекта потребуется веб-камера, открытые библиотеки Computer Vision OpenCV, tensorflow. В качестве приложения создана форма с 4мя (в последствии с 9ю) блоками, каждые 1,5 секунды загорается один случайный блок. Оператору дается 1 секунда для фокусировки взгляда на этом блоке и, затем, сохраняется снимок с веб-камеры с пометкой какой блок загорелся. Далее эти снимки используются для сбора данных по точности алгоритмов.
4.1 Технические проблемы
Традиционные бесконтактные системы отслеживания глаз имеют ряд проблем, которые необходимо учесть при расчете фокуса или при нахождении глаза.
Первая и самая главная проблема, это движение головы, о котором упоминалось в [11]. Старые системы отслеживания глаз требуют, чтобы пользователь продолжал удерживать голову неподвижно, чтобы точно зафиксировать данные. Алгоритмы, рассмотренные ранее и включающие в себя инфракрасное освещение, не поддерживают изменение положения головы в кадре.
Вторая проблема, с которой сталкивается область глазного трекинга, известна как проблема «Midas Touch». Эта проблема является прямым следствием движения глаз. Глаза используются как устройства ввода информации и поэтому нужно точно определять перемещение ли это или мелкие колебания (дрейфы).
4.2 Алгоритм
[Блок находится в стадии переработки]
Общий алгоритм построен на основе непрерывной обработке потока изображения.
Шаги цикла – это шаги, необходимые для получения всех необходимых данных из одного кадра.
Алгоритм определения направления взгляда:

4.3 Получение координат частей лица
Первым шагом алгоритма бесконтактного управления является поиск на изображении лица, а также отдельных его частей, а именно:
 Лицо
 Рот
 Нос
 Глаза
На основании взаимного относительного расположения этих частей на изображении можно судить о положении головы оператора. Также, местоположение глаз необходимо знать для работы алгоритма определения направления взгляда. Для решения данной задачи подходят несколько способов, рассмотренные выше.
4.4 Определение угла положения головы
В результате поиска частей лица на изображении, для каждой из них находится прямоугольная область, координаты центра которой можно использовать в дальнейшем. Полученные данные о расположении частей лица на изображении могут быть недостоверными из-за ошибок алгоритма распознавания. Поэтому, наряду с определением положения головы оператора по взаимному расположению частей лица на изображении, проводится ряд проверок, позволяющий отсеять недостоверные результаты. Пример такой проверки: линия, провед?нная через центры областей, 38 отмечающих губы и нос, пересекает отрезок, соединяющий центры областей глаз посередине и под прямым углом (с допустимой погрешностью). В итоге, координаты маркера на двухмерной плоскости, полученные на основе положения головы оператора, определяются по следующим формулам: 
B_1x=(N_x-(R_x+(R_x- L_x)/2+ M_x)/2) K_1x X+X/2;(4.4.1)
B_1y=(N_y-(R_y+(R_y- L_y)/2+ M_y)/2) K_1y Y+Y/2;(4.4.2)
где 
B1x, B1y – координаты результирующего маркера по осям x и y соответственно,
Rx, Ry – координаты центра области правого глаза,
Lx, Ly – координаты центра области левого глаза,
Nx, Ny – координаты центра области носа,
Mx, My – координаты центра области губ,
K1x, K1y – корректирующие коэффициенты, зависящие от характеристик камеры, различий в характере вертикальных и горизонтальных движений головы человека и подбираемые экспериментально.
X, Y – размер области, в пределах которой осуществляется управление, как правило это размер в пикселях экрана монитора.
4.5 Определение направления взгляда
Центры найденных эллипсов указывают на расположение зрачков. Затем смещение зрачков относительно центров областей глаз умножается на коэффициенты, линейно зависящие от положения головы оператора. В результате получаются координаты B2x и B2y результирующего маркера, определяемые направлением взгляда:
B_2x=((1- K_2x (B_1x-X/2) ) ??R?_x+ (1+ K_2x (B_1x-X/2) ) ??L?_x)/2 K_3x+X/2   (4.5.1)
B_2y=(??L?_x+ ??R?_y)/2 K_3y+ (B_1y-Y/2) K_2y+Y/2     (4.5.2) 
где 
?Rx, ?Ry – Смещение зрачка правого глаза
?Lx, ?Ly – Смещение зрачка левого глаза
K2x, K2y – Корректирующие коэффициенты, характеризующие влияние углового положения головы на изображение зрачков.
K3x, K3y – Корректирующие коэффициенты, зависящие от характеристик камеры, различий в характере вертикальных и горизонтальных движений глаз человека.
4.6 Объединение и аппроксимирование результата
Рассматриваемая система бесконтактного управления в качестве управляющих воздействий использует данные, полученные от разных подсистем, а именно: 
 Подсистема определения направления взгляда оператора.
 Подсистема определения поворота головы оператора.
Эти данные, в силу неоднородности их источников различаются по своим параметрам, таким как точность, достоверность и периодичность обновления. Например, подсистема определения направления взгляда оператора на основании распознавания зрачка глаза на видеоизображении дает результат с наивысшей для трех рассматриваемых каналов точностью, но из-за высокой вероятности возникновения ошибок распознавания второго рода, эти данные могут быть недостоверными. Это послужило причиной для создания алгоритма объединения и взаимной коррекции этих данных для выработки единого сигнала, который и будет использован при управлении. Представим желаемое управляющее воздействие в дискретный момент времени t как точку Ct на экранной плоскости, заданную дискретными координатами x и y, а воздействие, полученное по каналу i, как точку i Bt на этой же плоскости. В ходе разработки были опробованы два способа объединения сигналов – упрощенный и модифицированный.
4.6.1 Упрощенный способ объединения сигналов 
Первоначальный способ, возникший в результате разработки, заключается в получении результирующей точки Ct через усреднение координат точек i Bt :
C_t=((?_(i=1)^n??x_t^i  ?)/n  , (?_(i=1)^n??y_t^i  ?)/n  )  (4.6.1.1)

Пример упрощенного объединения сигналов
Подобный подход к решению задачи комплексирования является довольно простым и легко реализуемым, но не учитывает неоднородность данных, получаемых от разных подсистем. Поэтому целесообразно провести модификацию данного способа.
4.6.2 Модифицированный способ объединения сигналов 
Введем для каждого из каналов набор характеристических коэффициентов: 
Ri – достоверность данных канала i.
Si – точность данных канала i.
Ri – постоянная времени, характеризующая убывание актуальности данных канала i с течением времени Для начала, определим актуальность данных с канала, если они были получены не в текущий момент времени t. Особенности реализации подсистем таковы, что различные каналы работают асинхронно, выдавая результат по мере получения. То есть, для канала i в момент времени t есть интервал времени ?T_t^i , прошедшего с последнего опроса этого канала. Примем закон убывания актуальности A_t^i данных с канала i за:
A_t^i=e^((?T_t^i)/R_i )   (4.6.2.1)

 Затем, получим результирующую точку как средневзвешенное значение координат B_t^i (x_t^i, y_t^i ) от разных n каналов:
C_t^ =((?_(i=1)^n??x_t^i A_t^i S_i^  ?)/(?_(i=1)^n??A_t^i S_i^  ?),(?_(i=1)^n??y_t^i A_t^i S_i^  ?)/(?_(i=1)^n??A_t^i S_i^  ?))    (4.6.2.2)
Так как показания каналов могут быть недостоверными, исключим из результата данные от тех каналов, для которых расстояние от результирующей точки без уч?та рассматриваемого канала j больше, чем порог доверия Ri :
??((((?_(i=1)^(n, i?j)??x_t^i A_t^i S_i^  ?)/(?_(i=1)^(n, i?j)??A_t^i S_i^  ?)- x_t^j )^2+((?_(i=1)^n??y_t^i A_t^i S_i^  ?)/(?_(i=1)^n??A_t^i S_i^  ?)- y_t^j )^2 ) )?^ > R_j     (4.6.2.3)
На изображении ниже сигнал от подсистемы 3 не учитывается при получении результирующего сигнала, так как расстояние от общего центра С точек B1 и B2 до точки B3 больше, чем порог доверия R3.

Определение значений коэффициентов для рассматриваемого алгоритма, которые были бы оптимальны для решения задачи, является известной проблемой, по причине их количества (в данном случае их 6) и отсутствия ч?ткого критерия оптимальности. Для поиска искомых значений коэффициентов , , R S i i i ? при разработке системы бесконтактного управления использовался генетический алгоритм (ГА). Критерием отбора для генетического алгоритма принята корректная работа системы на обучающем примере, подготовленном следующим образом: Был произвед?н тестовый запуск системы, во время которого оператору предлагалось перемещать бесконтактным способом указатель на экране вслед за целью, движение которой определялось программно. Таким образом были получены как входные данные – записанные сигналы подсистем, так и желаемые выходные – положение цели. Далее, за критерий отбора было принято среднеквадратичное по времени отклонение результирующего воздействия, полученного в результате работы алгоритма объединения сигналов, от желаемого результата из обучающего примера.
      4.6.3 Итеративное сглаживание результата 
С целью обеспечить плавность управления целесообразно провести сглаживание результата с уч?том данных, полученных при обработке предыдущих кадров видеоизображения. Самым простым, но тем не менее дающим удовлетворительные результаты способом является усреднение по координатам результатов последних N итераций. При разработке опытного образца системы было принято N = 5. Кроме того, можно усовершенствовать сглаживание результата, применив фильтр Калмана [6]. Фильтр Калмана предназначен для рекурсивного оценивания вектора состояния априорно известной динамической системы, то есть для расч?та текущего состояния системы необходимо знать текущее измерение, а также предыдущее состояние самого фильтра. Таким образом, фильтр Калмана, подобно другим 45 рекурсивным фильтрам, реализован во временном, а не в частотном представлении, но в отличие от других подобных фильтров, фильтр Калмана оперирует не только оценками состояния, а еще и оценками неопределенности (плотности распределения) вектора состояния, опираясь на формулу Байеса условной вероятности. Наглядный пример возможностей фильтра — получение точных, непрерывно обновляемых оценок положения и скорости некоторого объекта по результатам временного ряда неточных измерений его местоположения. Рис. 36. Пример сглаживания выходного значения при помощи фильтра Калмана.
      4.7 Итеративное сглаживание результата 
1. Предложен алгоритм определения направления взгляда, работающий в соответствии с принятым ранее двухканальным подходом к построению системы. Алгоритм состоит из нескольких крупных структурных частей, подробно описанных в данной главе. 2. Приведены основные соотношения, используемые для преобразования координат найденных на изображении частей лица в координаты маркера на экранной плоскости системы. 3. Предложен способ объединения и коррекции сигналов от разных каналов системы бесконтактного управления. 4. Чтобы сгладить движение указателя, осуществляемое при помощи системы бесконтактного управления и тем самым повысить плавность управления, можно использовать усреднение координат маркера по времени или применить фильтр Калмана.

Глава 5. Реализация проекта
5.1 Поиск пары глаз
Как уже было сказано ранее, поиск пары глаз осуществляется с помощью каскадов Хаара. Библиотека OpenCV поддерживает работу с классификаторами Хаара, данный функционал встроен в библиотеку. В ходе разработки было выяснено, что лучше использовать классификаторы Хаара следующим образом:
 Классификаторы нужно загрузить на этапе инициализации программы
 Изображение требуется подготовить перед запуском поиска. Изображение приводится к черно-белому виду, так как в данном случае классификаторы отрабатывают более устойчиво.
Метод обнаружения Хаара принимает на вход изображение, каскад классификаторов Хаара, переменную для хранения результата, а затем несколько других необязательных параметров. Затем эта функция возвращает последовательность обнаруженных граней, состоящая из координат x и y, а также ширина и высота найденной пары глаз. Для более наглядного тестирования, вокруг пары глаз рисуется прямоугольник. Для проверки работы алгоритма, будем считать, что находится всегда только одна пара глаз, именно та, которая и будет управлять системой.

Пример обнаружения пары глаз
5.2 Определение зрачка
Изображение пары глаз делится ровно пополам. Далее будет разъяснена реализация получения координат для одного глаза, но эта реализация справедлива и для другого. 
Изначально изображение подвергается инверсии (изображение изначально цветное). Инверсия производится с помощью библиотеки AForge уже знакомой из [13]. Результат инверсии на изображении ниже.
                                                                      
                        Исходное изображение                                                              Инвертированное изображение

5.2.1 Бинаризация изображения
Следующий шаг – это бинаризация изображения, использован для этого алгоритм Брэдли. Процесс бинаризации – это перевод цветного (или в градациях серого) изображения в двухцветное черно-белое. Главным параметром такого преобразования является порог t – значение, с которым сравнивается яркость каждого пикселя. По результатам сравнения, пикселю присваивается вес 0 или 1. Существуют различные методы бинаризации, которые можно условно разделить на две группы – глобальные и локальные. В первом случае величина порога остается неизменной в течение всего процесса бинаризации. Во втором изображение разбивается на области, в каждой из которых вычисляется локальный порог.
Существуют разные виды алгоритмов бинаризации изображения (метод Ниблэка, метод Кристиана). Наиболее быстрым из классических локальных алгоритмов считается метод Ниблэка, но он плохо работает с низкоконтрастными неровностями фона, которые в случае изображения глаза и близлежащего фона заполняют изображение чуть меньше, чем полностью. Чтобы исправить этот недостаток, было разработано несколько алгоритмов на основе метода Ниблэка, называемых „ниблэковскими“. В качестве примера, метод Кристиана, показывал хорошие результаты, и рассматривался как подходящий вариант. Однако на изображении с нестабильным расстоянием от камеры, после применения этого алгоритма появлялись искажения.
Трудность алгоритма бинаризации заключается в нахождении порогового значения, которое должно максимально надежно отделять символы не только от фона, но и от шума, теней, бликов и подобного. Часто для этого прибегают к методам математической статистики. В методе Брэдли подход с другой стороны – со стороны интегральных изображений. 
Интегральные изображения – это не только эффективный и быстрый (всего за один проход по изображению) способ найти сумму значений пикселей, но и простой способ найти среднее значение яркости в пределах заданного участка изображения.
Допустим, у нас есть 8-битное изображение в оттенках серого (цветное изображение можно перевести в оттенки серого, пользуясь формулой I=0.2125R+0.7154G+0.0721B). В таком случае, значение элемента интегрального изображения рассчитывается по формуле:
S(x, y)=I(x,y)+ S(x-1, y)+ S(x, y-1)- S(x-1, y-1);
где S – результат предыдущих итераций для данной позиции пикселя, I – яркость пикселя исходного изображения. Если координаты выходят за пределы изображения, они считаются нулевыми. Для понимания принцип работы представлен на схеме ниже:

Хитрость алгоритма состоит в том, что, один раз составив интегральную матрицу изображения, можно быстро вычислять сумму значений пикселей любой прямоугольной области в пределах этого изображения. Пусть ABCD – интересующая нас прямоугольная область.

Тогда суммарная яркость S в этой области вычисляется по формуле:
S(x,y)=S(A)+ S(D)- S(B)- S(C)
где S(A), S(B), S(C) и S(D) – значения элементов интегральной матрицы в направлении на „северо-запад“ от пересечений сторон прямоугольника:

Реализацию метода можно посмотреть в листинге программы. Результат бинаризации:
                                                                      
               Инвертированное (ЧБ) изображение                                        Бинаризированное изображение

Применение бинаризации объясняется тем, что в таком случае на определения зрачка не влияет контраст и яркость изображения. Для того что б проверить данное утверждение был реализован модуль изменяющий контраст и яркость изображения. Результатом такой проверки стало подтверждение высказывания. Для дальнейшего снижения шума применяется сглаживающий фильтр Гаусса.
Следующий этап – поиск окружностей на изображении. Используемая для этого функция называется cvHoughCircles. Она ищет в изображении форму эллипса, которая упомянутая в нескольких работах. Чтобы функция обнаруживала только лучший круг на изображении, требуется правильно установить самый важный параметр – минимальное расстояние до размера изображения. Этот параметр представляет собой минимальное расстояние между двумя обнаруженными кругами. Для наглядности на изображении зрачка отображаются круги (те, что находит метод cvHoughCircles).
5.3 Поиск угла
Поскольку оба глаза обнаружены, и обнаружение углов использует ROI (Region Of Interest) от обнаружения глаз, то их достаточно просто вычислить. Угловое детектирование работает, уравнивая гистограмму изображения, а после вызывается метод OpenCV cvGoodFeaturesToTrack. Эта функция находит наиболее заметные углы изображения. Функция имеет параметр с именем maxCorners, который позволяет пользователю указать количество возвращаемых углов. Функция также оценивает углы по силе, поэтому, выбираем maxCorners = 1, ведь нужно получить только самый сильный угол. Проблема была быстро обнаружена, самый сильный угол в полном изображении глаза может быть либо глазным углом, либо ошибочным углом, возникшим из-за рельефа вокруг глаз. Таким образом, лучше организовывать поиск угла только в изображении зрачка, найденном шагом ранее. Далее данные о координатах зрачка и угла передаются в модуль математики MathModule, реализованный специально для более точного подсчета координат и дальнейшего применения аппроксимации координат курсора.


Глава 6. Экспериментальная оценка эффективности системы
[
 Реализация на основе алгоритма Виола-Джонса
 Реализация сверточной нейронной сети
 Реализация приложения для создания обущающей (тестирующей выборки).
 Сбор и сравнение данных
]
Заключение


  Список литературы
 А.Л. Ярбус Академия наук СССР «Роль движений глаз в процессе зрения». Москва 1996г.
 Jacob, R. J. K. Eye tracking in advanced interface design, 1995.
 Klingenhoefer, S., and Bremmer, F. Saccadic suppression of displacement in face of saccade adaptation. Vision Research 51, 8 (2011), 881 – 889. Perception and Action: Part II.
 Гиппенрейтер Ю. Б. Движения человеческого глаза / Ю. Б. Гиппенрейтер.
 Grossberg, S., Srihasam, K., and Bullock, D. Neural dynamics of saccadic and smooth pursuit eye movement coordination during visual tracking of unpredictably moving targets. Neural Networks 27, 0 (2012), 1 – 20
 Mouse cursor control with head and eye movements: A low-cost approach by Yat-Sing Yeung, BSc. 1220 Vienna, 2012
 Gao, D., Yin, G., Cheng, W., and Feng, X. Non-invasive eye tracking technology based on corneal reflex. Procedia Engineering 29, 0 (2012), 3608 – 3612. 2012 International Workshop on Information and Electronics Engineering.
 P. Viola and M. Jones. Robust real-time face detection. IJCV 57(2), 2004
 Lienhart R., Kuranov E., Pisarevsky V.: Empirical analysis of detection cascades of boosted classifiers for rapid object detection. In: PRS 2003, pp. 297-304 (2003)
 Huang, Y., Wang, Z., and Ping, A. Non-contact gaze tracking with head movement adaptation based on single camera, 2009.
 Sewell, W., and Komogortsev, O. Real-time eye gaze tracking with an unmodified commodity webcam employing a neural network. In Proceedings of the 28th of the international conference extended abstracts on Human factors in computing systems. New York, NY, USA, 2010.
 Torricelli, D., Conforto, S., Schmid, M., and DAlessio, T. A neuralbased remote eye gaze tracker under natural head motion. Computer Methods and Programs in Biomedicine 92, 1 (2008), 66 – 78.
 Соловьев С.М., Разработка системы альтернативного управления компьютером. Управление цветным объектом. г. Ярославль, 2016г.
 @Llammt, «Бинаризация изображений: алгоритм Брэдли», 2016. https://habrahabr.ru/post/278435/
 Derek Bradley , Gerhard Roth Adaptive thresholding using the integral image, 2007.
 Gaze Tracking Using A Regular Web Camera, Grahamstown, South Africa, 2012.
 P. Viola and M.J. Jones, «Rapid Object Detection using a Boosted Cascade of Simple Features», proceedings IEEE Conf. on Computer Vision and Pattern Recognition (CVPR 2001), 2001
 P. Viola and M.J. Jones, «Robust real-time face detection», International Journal of Computer Vision, vol. 57, no. 2, 2004., pp.137–154
 Р.Гонсалес, Р.Вудс, «Цифровая обработка изображений», ISBN 5-94836-028-8, изд-во: Техносфера, Москва, 2005. – 1072 с.
 Минский, Пейперт, с. 11—18.
 Розенблатт, Ф., с. 85—88.
  Donald Olding Hebb. The Organization of Behavior: A Neuropsychological Theory. — Wiley, 1949. — 335 p. Современное издание: Donald Olding Hebb. The Organization of Behavior: A Neuropsychological Theory. — Lawrence Erlbaum Associates, 2002. — 335 p.  
 Розенблатт Ф., с. 102.
 Розенблатт Ф., с. 86
 Хайкин С., 2006, с. 225—243, 304—316.

     39
     
     
     
     
